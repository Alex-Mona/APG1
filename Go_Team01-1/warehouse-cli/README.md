Для того чтобы проверить работу проекта, можно выполнить следующие шаги:

./server 8765        # Запуск первого сервера
./server 9876 8765   # Запуск второго сервера

./client


### 1. **Запуск сервера**
   Убедитесь, что ваш сервер работает на правильном порту. Для этого выполните команду для запуска сервера:

   ```bash
   go run main.go
   ```

   Сервер должен запуститься на порту `8765` (или другом, если вы указали его в аргументах при запуске).

   Если сервер успешно запущен, вы должны увидеть сообщение:

   ```
   Server started on :8765
   ```

### 2. **Выполнение запросов через curl**

   Вы можете использовать `curl`, чтобы отправить запросы на ваш сервер для тестирования операций `SET`, `GET` и `DELETE`.

   **2.1. Проверка команды `SET`**

   Отправляем команду для добавления ключа-значения в формате UUID4:

   ```bash
   curl "http://127.0.0.1:8765/set?key=0d5d3807-5fbf-4228-a657-5a091c4e497f&value=%7B%22name%22%3A%22Chapayev%27s%20Mustache%20comb%22%7D"
   ```

   Если все прошло успешно, вы должны получить ответ:
   
   ```
   Created (2 replicas)
   ```

   **2.2. Проверка команды `GET`**

   Чтобы получить значение по ключу, используйте команду `GET` с правильным UUID:

   ```bash
   curl "http://127.0.0.1:8765/get?key=0d5d3807-5fbf-4228-a657-5a091c4e497f"
   ```

   Вы должны получить JSON-ответ с объектом:

   ```json
   {"name": "Chapayev's Mustache comb"}
   ```

   **2.3. Проверка команды `DELETE`**

   Чтобы удалить запись по ключу, используйте:

   ```bash
   curl -X DELETE "http://127.0.0.1:8765/delete?key=0d5d3807-5fbf-4228-a657-5a091c4e497f"
   ```

   В случае успеха вы должны получить ответ:

   ```
   Deleted (2 replicas)
   ```

### 3. **Тестирование на неправильный формат UUID**
   
   Чтобы убедиться, что проверка UUID работает правильно, выполните команду с неверным ключом:

   ```bash
   curl "http://127.0.0.1:8765/set?key=12345&value=%7B%22name%22%3A%22Chapayev%27s%20Mustache%20comb%22%7D"
   ```

   В ответ вы должны увидеть сообщение об ошибке:

   ```
   Key is not a proper UUID4
   ```

Работает все что выше, для сервера


### 4. **Проверка репликации и работы кластера**
   
   Для этого необходимо запустить несколько серверных экземпляров и убедиться, что данные реплицируются. В каждом экземпляре сервера должны быть прописаны конфигурации для репликации. Можно добавить ещё один сервер, указав его порт при запуске:

   ```bash
   go run main.go 9876
   ```

   После этого с клиента можно отправить запросы на разные серверы, проверяя, что данные сохраняются и доступны на других узлах.

### 5. **Работа с клиентом**
   
   Запустите клиентское приложение:

   ```bash
   go run client.go
   ```

   Пример сессии:

   ```bash
   > SET 0d5d3807-5fbf-4228-a657-5a091c4e497f '{"name": "Chapayev's Mustache comb"}'
   Created (2 replicas)
   
   > GET 0d5d3807-5fbf-4228-a657-5a091c4e497f
   {"name":"Chapayev's Mustache comb"}

   > DELETE 0d5d3807-5fbf-4228-a657-5a091c4e497f
   Deleted (2 replicas)
   ```

### Объяснение работы функций:

### server.go:

### Основные функции

1. **`main`**:
   - **Назначение**: Главная функция, запускающая сервер и инициализирующая узел.
   - **Работа**:
     - Проверяет, был ли передан порт.
     - Если указан другой узел, подключается к нему, иначе инициализирует текущий узел как лидера.
     - Настраивает обработчики HTTP для различных операций (GET, SET, DELETE, HEARTBEAT, JOIN).
     - Запускает мониторинг узлов в отдельной горутине.

2. **`handleGet`**:
   - **Назначение**: Обработчик для получения значения по ключу.
   - **Работа**:
     - Извлекает ключ из запроса.
     - Проверяет наличие ключа в `dataStore`.
     - Если ключ найден, возвращает его значение, иначе отправляет ошибку 404.

3. **`handleSet`**:
   - **Назначение**: Обработчик для установки значения по ключу.
   - **Работа**:
     - Проверяет, является ли текущий узел лидером. Если нет, отправляет ошибку 403.
     - Извлекает ключ и значение из запроса, проверяет корректность формата ключа (UUID4).
     - Сохраняет значение в `dataStore` и запускает репликацию на другие узлы.

4. **`handleDelete`**:
   - **Назначение**: Обработчик для удаления значения по ключу.
   - **Работа**:
     - Проверяет, является ли текущий узел лидером. Если нет, отправляет ошибку 403.
     - Удаляет ключ из `dataStore` и запускает репликацию удаления на другие узлы.

5. **`handleHeartbeat`**:
   - **Назначение**: Обработчик для проверки состояния узла.
   - **Работа**:
     - Возвращает информацию о том, является ли текущий узел лидером, и фактор репликации.

6. **`handleJoinCluster`**:
   - **Назначение**: Обработчик для присоединения узла к кластеру.
   - **Работа**:
     - Извлекает адрес и порт из запроса.
     - Добавляет новый узел в `nodes` и выводит информацию о присоединении.

7. **`connectToCluster`**:
   - **Назначение**: Подключение к существующему узлу.
   - **Работа**:
     - Формирует URL для запроса на присоединение и отправляет его, добавляя текущий узел к кластеру.

8. **`replicateToNodes`**:
   - **Назначение**: Репликация данных на другие узлы кластера.
   - **Работа**:
     - Перебирает узлы и отправляет запросы на установку значений (SET) на другие узлы в соответствии с фактором репликации.
     - Логирует результаты репликации и предупреждает, если репликация выполнена не на все узлы.

9. **`monitorNodes`**:
   - **Назначение**: Мониторинг состояния узлов в кластере.
   - **Работа**:
     - Периодически проверяет состояние узлов.
     - Удаляет узлы, которые не отправляли сердцебиения в течение 10 секунд.
     - Если узел-лидер неактивен, вызывает функцию для выбора нового лидера.

10. **`electNewLeader`**:
    - **Назначение**: Выбор нового лидера среди доступных узлов.
    - **Работа**:
      - Перебирает узлы и выбирает первый доступный узел в качестве нового лидера, если текущий лидер неактивен.
      - Устанавливает флаг нового лидера и обновляет информацию о кластере.

### client.go:

### Основные функции

1. **`main()`**:
   - Начальная точка программы.
   - Устанавливает соединение с распределенной базой данных.
   - Выводит доступные команды в консоль.
   - Запускает бесконечный цикл для считывания и обработки команд пользователя.

2. **`get(key string)`**:
   - Отправляет GET-запрос к текущему узлу для получения значения по указанному ключу.
   - Если запрос успешен и узел отвечает кодом 200, считывает и выводит значение.
   - В случае ошибки отправки запроса, вызывает `switchNode()` для переключения на другой узел.

3. **`set(key, value string)`**:
   - Отправляет POST-запрос к текущему узлу для установки значения по указанному ключу.
   - Запрашивает URL с закодированным ключом, а значение передает в теле запроса.
   - Если запрос успешен, выводит сообщение об успешном обновлении/создании записи. В случае ошибки переключается на другой узел.

4. **`delete(key string)`**:
   - Отправляет DELETE-запрос к текущему узлу для удаления значения по указанному ключу.
   - Если запрос успешен, выводит сообщение о удалении. В случае ошибки переключается на другой узел.

5. **`joinCluster(address, port string)`**:
   - Отправляет GET-запрос к текущему узлу для присоединения нового узла к кластеру.
   - Если узел успешно присоединился, выводит сообщение об успехе. В случае ошибки выводит сообщение об ошибке.

6. **`switchNode()`**:
   - Переключает текущее соединение на следующий узел в списке узлов.
   - Если узел не доступен, находит следующий доступный узел и меняет текущее соединение.
   - Выводит сообщение о переключении, если узел найден, и сообщение об отсутствии доступных узлов, если все узлы недоступны.

### Дополнительные моменты
- **`nodes`**: Это массив, который содержит список доступных узлов для переключения в случае ошибок.
- **`currentNode`**: Переменная, хранящая адрес текущего узла, к которому подключен клиент.
- **Использование `bufio.Scanner`**: Для чтения пользовательского ввода из консоли, позволяя пользователю вводить команды.

### Обработка ошибок
В каждой из функций, кроме обработки успешного ответа от сервера, присутствует обработка ошибок. В случае возникновения ошибок при выполнении запросов или неверном формате данных выводятся соответствующие сообщения, что помогает пользователю понять, что произошло не так.

Таким образом, данный код создает удобный интерфейс для работы с распределенной системой, позволяя пользователю выполнять операции над хранимыми данными через командную строку.