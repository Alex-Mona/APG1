Программа, реализует алгоритм "SleepSort". Этот алгоритм — скорее игрушечный пример, чем полезная для реальной жизни сортировка, и он работает с использованием параллельных горутин. Вот как работает каждая функция:

### 1. `sleepSort`

```go
func sleepSort(nums []int) chan int {
	out := make(chan int)

	// Если входной слайс пуст, сразу закрываем канал
	if len(nums) == 0 {
		close(out)
		return out
	}

	// Запускаем горутины для каждого числа
	for _, num := range nums {
		go func(n int) {
			time.Sleep(time.Duration(n) * time.Second) // Спим количество секунд, равное числу
			out <- n                                  // Отправляем число в канал
		}(num)
	}

	go func() {
		time.Sleep(time.Duration(max(nums)) * time.Second) // Ждём завершения самой длинной паузы
		close(out)                                         // Закрываем канал, когда все горутины завершат работу
	}()

	return out
}
```

#### Описание:
- **Входной параметр**: функция принимает слайс целых чисел `nums []int`.
- **Создание канала**: `out := make(chan int)` создаёт канал типа `int`. Этот канал будет использоваться для передачи отсортированных чисел.
- **Проверка на пустой слайс**: Если длина входного слайса равна нулю, канал закрывается и функция завершает свою работу.
- **Горутины для каждого числа**: Для каждого числа в слайсе создаётся отдельная горутина, которая "спит" (использует `time.Sleep`) количество секунд, равное значению числа. После "сна" число отправляется в канал.
- **Закрытие канала**: Вторая горутина выполняет ожидание, равное максимальному числу в слайсе (чтобы дождаться завершения всех других горутин), и затем закрывает канал.

#### Важные моменты:
- В каждой горутине задержка (сон) соответствует значению числа, и это приводит к тому, что меньшие числа будут переданы в канал раньше, чем большие, тем самым имитируя сортировку.
- После завершения всех задержек канал закрывается, чтобы показать, что больше значений не будет отправлено.

### 2. `max`

```go
func max(nums []int) int {
	if len(nums) == 0 {
		return 0 // Возвращаем 0, если слайс пуст
	}
	maxVal := nums[0]
	for _, n := range nums {
		if n > maxVal {
			maxVal = n
		}
	}
	return maxVal
}
```

#### Описание:
- **Входной параметр**: функция принимает слайс целых чисел.
- **Возвращаемое значение**: функция возвращает максимальное число в слайсе.
- **Логика работы**: 
  - Если слайс пуст, возвращается 0.
  - Перебираются все элементы слайса, и в переменную `maxVal` сохраняется максимальное значение. В конце оно возвращается.

### 3. `main`

```go
func main() {
	// Пример входных данных
	input := []int{3, 1, 4, 2}

	// Вызываем sleepSort и читаем результаты
	result := sleepSort(input)

	// Выводим отсортированные значения
	for num := range result {
		fmt.Println(num)
	}
}
```

#### Описание:
- **Главная функция программы**:
  - Входные данные: слайс целых чисел `input := []int{3, 1, 4, 2}`.
  - Вызов функции `sleepSort`: она возвращает канал с отсортированными числами.
  - Чтение из канала: цикл `for num := range result` читает числа по мере их поступления из канала и выводит их на экран.

### Как работает вся программа:

1. В `main` создаётся слайс чисел `[3, 1, 4, 2]`.
2. Вызывается функция `sleepSort`, которая запускает горутины для каждого числа. Каждая горутина "засыпает" на количество секунд, равное числу, а затем отправляет это число в канал.
3. После завершения задержек числа передаются в канал в порядке возрастания.
4. Цикл в `main` считывает числа из канала и выводит их на экран в отсортированном порядке.

### Пример вывода:

```
1
2
3
4
```

### Итог:
- Этот пример демонстрирует концепцию конкурентного программирования в Go с помощью горутин и каналов.
- Алгоритм работает, потому что числа передаются в канал после "сна", который зависит от их значения. Это гарантирует, что меньшие числа будут отправлены первыми, имитируя сортировку.

### Описание работы тестов
В файле `sleepsort_test.go` находятся два теста для проверки работы функции `sleepSort`. Тесты используют стандартную библиотеку тестирования Go (`testing`), которая позволяет автоматически проверять корректность работы программы.

### 1. `TestSleepSort`

```go
func TestSleepSort(t *testing.T) {
	input := []int{3, 1, 4, 2}
	result := sleepSort(input)

	expected := []int{1, 2, 3, 4}
	var output []int

	for num := range result {
		output = append(output, num)
	}

	for i, v := range expected {
		if output[i] != v {
			t.Errorf("Expected %d, got %d", v, output[i])
		}
	}
}
```

#### Описание работы:
1. **Исходные данные**: `input := []int{3, 1, 4, 2}`. Это массив целых чисел, который мы передаем в функцию `sleepSort`.
2. **Ожидаемый результат**: `expected := []int{1, 2, 3, 4}`. Мы ожидаем, что результат работы функции будет отсортированный массив.
3. **Вызов функции `sleepSort`**: `result := sleepSort(input)`. Мы передаем входные данные в `sleepSort`, которая возвращает канал, по которому будут поступать отсортированные числа.
4. **Чтение результатов**: Используя цикл `for num := range result`, мы читаем все числа из канала и записываем их в массив `output`.
5. **Сравнение результата с ожиданием**: После получения всех данных из канала, программа сравнивает элементы массива `output` с массивом `expected`. Если хоть один элемент не совпадает, тест завершится с ошибкой: `t.Errorf("Expected %d, got %d", v, output[i])`.

#### Задача теста:
Тест проверяет, что функция `sleepSort` корректно сортирует массив целых чисел, и числа поступают в канал в правильном (возрастающем) порядке.

### 2. `TestSleepSortEmptyInput`

```go
func TestSleepSortEmptyInput(t *testing.T) {
	input := []int{}
	result := sleepSort(input)

	// Ожидаем, что канал сразу закроется
	select {
	case _, ok := <-result:
		if ok {
			t.Errorf("Expected closed channel for empty input")
		}
	case <-time.After(1 * time.Second):
		t.Errorf("Test timed out")
	}
}
```

#### Описание работы:
1. **Исходные данные**: `input := []int{}`. В этом тесте мы передаем в функцию `sleepSort` пустой массив.
2. **Ожидаемый результат**: Мы ожидаем, что в случае пустого массива функция сразу закроет канал, так как нет чисел для сортировки.
3. **Вызов функции `sleepSort`**: `result := sleepSort(input)`. Мы передаем пустой массив в функцию, которая возвращает канал.
4. **Проверка закрытия канала**:
   - Внутри блока `select` проверяется, закрыт ли канал. Если канал был закрыт, блок `_, ok := <-result` выполнится с `ok == false`.
   - Если канал не закрыт (что является ошибкой для пустого ввода), программа выдаст ошибку: `t.Errorf("Expected closed channel for empty input")`.
   - Если тест "зависнет" (например, если функция не закроет канал), через 1 секунду сработает тайм-аут: `t.Errorf("Test timed out")`.

#### Задача теста:
Тест проверяет, что функция `sleepSort` правильно обрабатывает случай с пустым массивом. В этом случае канал должен быть закрыт сразу же, так как нечего сортировать.

### Итог:
- **`TestSleepSort`** проверяет, что функция корректно сортирует массив целых чисел и выводит их в правильном порядке.
- **`TestSleepSortEmptyInput`** проверяет, что функция корректно работает с пустым массивом, закрывая канал сразу же.